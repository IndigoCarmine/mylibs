from typing import Callable, Iterator, Protocol
import MDAnalysis as mda
from functools import total_ordering

@total_ordering
class Recorder:
    calc_name: str
    values: list[tuple[str, float]]
    log_data: list[str]

    def __init__(self, calculation_name: str): ...
    def log(self, val): ...
    def add_value(self, name: str, val: float): ...
    def add_value_of_default_array_analysis(self, name: str, array: float): ...
    def get_all_valuename(self) -> list[str]: ...
    def concat(self, recorder: "Recorder"): ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...

def generate_excel(file_name: str, recoders: list[Recorder]): ...
def mixing_recorders(
    base_recorder_list: list[Recorder], recorder_list: list[Recorder]
) -> list[Recorder]: ...
def perocess_files(
    calculation_basedir: str,
    last_calc,
    work: Callable[[str], Recorder],
    do_parallel: bool = False,
) -> list[Recorder]: ...
def analyze_trj(
    calculation_basedir: str,
    last_calc,
    work: Callable[[mda.Universe, str], Recorder],
    do_parallel: bool = False,
) -> list[Recorder]: ...
def get_calcname(calc_path: str) -> str: ...
def grouping[T](groups: list[T], group_size: int) -> Iterator[list[T]]: ...

class _Addable[T](Protocol): ...

def concat(group: list[_Addable]) -> _Addable: ...
def make_analyze_command_script(
    basedir: str, calcname: str, command: str, commandname: str
): ...
